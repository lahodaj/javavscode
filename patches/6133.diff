diff --git a/ide/api.lsp/apichanges.xml b/ide/api.lsp/apichanges.xml
index 10d84382475c..59a1778b633e 100644
--- a/ide/api.lsp/apichanges.xml
+++ b/ide/api.lsp/apichanges.xml
@@ -51,6 +51,19 @@
 <!-- ACTUAL CHANGES BEGIN HERE: -->
 
 <changes>
+    <change id="CommandProvider">
+        <api name="LSP_API"/>
+        <summary>Added CommandProvider interface</summary>
+        <version major="1" minor="22"/>
+        <date day="30" month="11" year="2023"/>
+        <author login="jlahoda"/>
+        <compatibility binary="compatible" source="compatible" addition="yes" deletion="no"/>
+        <description>
+            <a href="@TOP@/org/netbeans/spi/lsp/CommandProvider.html">CommandProvider</a>
+            has been added to allow server provide arbitrary commands runnable from a client.
+        </description>
+        <class package="org.netbeans.spi.lsp" name="CommandProvider"/>
+    </change>
     <change id="SignatureInformation">
         <api name="LSP_API"/>
         <summary>Added SignatureInformation and SignatureInformationCollector</summary>
diff --git a/ide/api.lsp/manifest.mf b/ide/api.lsp/manifest.mf
index 3bfd176abc..b9e46648cf 100644
--- a/ide/api.lsp/manifest.mf
+++ b/ide/api.lsp/manifest.mf
@@ -1,5 +1,5 @@
 Manifest-Version: 1.0
 OpenIDE-Module: org.netbeans.api.lsp/1
 OpenIDE-Module-Localizing-Bundle: org/netbeans/api/lsp/Bundle.properties
-OpenIDE-Module-Specification-Version: 1.20
+OpenIDE-Module-Specification-Version: 1.22
 AutoUpdate-Show-In-Client: false
diff --git a/ide/api.lsp/src/org/netbeans/spi/lsp/CommandProvider.java b/ide/api.lsp/src/org/netbeans/spi/lsp/CommandProvider.java
new file mode 100644
index 000000000000..eb3f41b63c7e
--- /dev/null
+++ b/ide/api.lsp/src/org/netbeans/spi/lsp/CommandProvider.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.spi.lsp;
+
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * A provider for commands that a language client can run in the language server.
+ *
+ * @since 1.18
+ */
+public interface CommandProvider {
+
+    /**
+     * Names of commands supported by this provider.
+     *
+     * @return names of commands supported by this provider.
+     */
+    public Set<String> getCommands();
+
+    /**
+     * Run the specified command with the specified arguments.
+     *
+     * @param command the command to run
+     * @param arguments the command-specific arguments
+     * @return a result of the command
+     */
+    public CompletableFuture<Object> runCommand(String command, List<Object> arguments);
+
+}
diff --git a/java/java.lsp.server/nbcode/integration/src/org/netbeans/modules/nbcode/integration/commands/ProjectAuditCommand.java b/java/java.lsp.server/nbcode/integration/src/org/netbeans/modules/nbcode/integration/commands/ProjectAuditCommand.java
index 05e8f12cfc..1c36601f94 100644
--- a/java/java.lsp.server/nbcode/integration/src/org/netbeans/modules/nbcode/integration/commands/ProjectAuditCommand.java
+++ b/java/java.lsp.server/nbcode/integration/src/org/netbeans/modules/nbcode/integration/commands/ProjectAuditCommand.java
@@ -24,15 +24,12 @@ import com.google.gson.JsonPrimitive;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.eclipse.lsp4j.CodeAction;
-import org.eclipse.lsp4j.CodeActionParams;
 import org.netbeans.api.project.FileOwnerQuery;
 import org.netbeans.api.project.Project;
 import org.netbeans.api.project.ProjectInformation;
@@ -42,10 +39,8 @@ import org.netbeans.modules.cloud.oracle.OCIProfile;
 import org.netbeans.modules.cloud.oracle.adm.AuditOptions;
 import org.netbeans.modules.cloud.oracle.adm.AuditResult;
 import org.netbeans.modules.cloud.oracle.adm.ProjectVulnerability;
-import org.netbeans.modules.java.lsp.server.protocol.CodeActionsProvider;
-import org.netbeans.modules.java.lsp.server.protocol.NbCodeLanguageClient;
 import org.netbeans.modules.java.lsp.server.protocol.UIContext;
-import org.netbeans.modules.parsing.api.ResultIterator;
+import org.netbeans.spi.lsp.CommandProvider;
 import org.openide.DialogDisplayer;
 import org.openide.NotifyDescriptor;
 import org.openide.filesystems.FileObject;
@@ -57,8 +52,8 @@ import org.openide.util.lookup.ServiceProvider;
  *
  * @author sdedic
  */
-@ServiceProvider(service = CodeActionsProvider.class)
-public class ProjectAuditCommand extends CodeActionsProvider {
+@ServiceProvider(service = CommandProvider.class)
+public class ProjectAuditCommand implements CommandProvider {
     private static final Logger LOG = Logger.getLogger(ProjectAuditCommand.class.getName());
     
     /**
@@ -86,24 +81,43 @@ public class ProjectAuditCommand extends CodeActionsProvider {
             COMMAND_LOAD_AUDIT_OLD
     ));
     
-    @Override
-    public List<CodeAction> getCodeActions(NbCodeLanguageClient client, ResultIterator resultIterator, CodeActionParams params) throws Exception {
-        return Collections.emptyList();
-    }
-    
     private final Gson gson;
 
     public ProjectAuditCommand() {
         gson = new Gson();
     }
 
+    /**
+     * Implements commands {@code nbls.projectAudit.execute} and {@code nbls.projectAudit.display}. The command accepts parameters
+     * <ol>
+     * <li>URI that identifies the project or a file within a project. If the file is not a part of a project, an exception is thrown
+     * <li>knowledgebase OCID. It must not be empty and the knowledgebase must exist.
+     * <li>options structure, optional.
+     * </ol>
+     * If the project does not support vulnerability audits, an exception is thrown. The following options are supported:
+     * <ul>
+     * <li><b>profile</b> : string - OCI profile to use for communication (default: null = default profile)
+     * <li><b>force</b> : boolean - forces audit execution in OCI, bypasses local caches and older audit results (default: false).
+     * <li><b>compute</b> : boolean - for .display, computes the audit, if there are no results in OCI (default: true)
+     * <li><b>disableCache</b> : boolean - do not load from local cache (default: false)
+     * <li><b>suppressErrors</b> : boolean - suppresses displaying errors by NBLS, only fails the Future with an exception (default: false)
+     * <li><b>configPath</b> : string - custom OCI config path (default: null)
+     * <li><b>returnData</b> : boolean - if true, summary data is returned from the command. If false, the command just indicates success, returns audit OCID (default: false).
+     * <li><b>displaySummary</b> : boolean - if true, NBLS displays audit summary at completion of the command (default: true)
+     * </ul>
+     * The .execute command defaults to {@code force = true}.
+     * @param client the LSP client to communicate with
+     * @param command the command name
+     * @param arguments arguments to the command
+     * @return Future that contains audit ID or response structure {@link AuditResult}.
+     */
     @NbBundle.Messages({
         "# {0} - project name",
         "# {1} - cause message",
         "ERR_KnowledgeBaseSearchFailed=Could not search for knowledge base of project {0}: {1}"
     })
     @Override
-    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {
+    public CompletableFuture<Object> runCommand(String command, List<Object> arguments) {
         if (arguments.size() < 3) {
             throw new IllegalArgumentException("Expected 3 parameters: resource, compartment, knowledgebase");
         }
@@ -131,7 +145,7 @@ public class ProjectAuditCommand extends CodeActionsProvider {
         }
         
         String knowledgeBase = ((JsonPrimitive) arguments.get(1)).getAsString();
-        Object o = arguments.get(2);
+        Object o = arguments.size() > 2 ? arguments.get(2) : new JsonObject();
         if (!(o instanceof JsonObject)) {
             throw new IllegalArgumentException("Expected structure, got  " + o);
         }
@@ -142,6 +156,8 @@ public class ProjectAuditCommand extends CodeActionsProvider {
         LOG.log(Level.FINE, "Running audit command with context: {0}", ctx);
         
         boolean forceAudit = options.has("force") && options.get("force").getAsBoolean();
+        boolean executeIfNotExists = forceAudit || !options.has("compute") ||  options.get("compute").getAsBoolean();
+        boolean disableCache = forceAudit || (options.has("disableCache") && options.get("disableCache").getAsBoolean());
         String preferredName = options.has("auditName") ? options.get("auditName").getAsString() : null;
         
         final OCIProfile auditWithProfile;
@@ -210,7 +226,11 @@ public class ProjectAuditCommand extends CodeActionsProvider {
                     break;
                 case COMMAND_LOAD_AUDIT:
                 case COMMAND_LOAD_AUDIT_OLD: {
-                    exec = v.runProjectAudit(kb, auditOpts.setRunIfNotExists(forceAudit).setAuditName(preferredName));
+                    exec = v.runProjectAudit(kb, 
+                            auditOpts.
+                                    setRunIfNotExists(executeIfNotExists).
+                                    setForceAuditExecution(forceAudit).
+                                    setDisableCache(disableCache));
                     break;
                 }
                 default:

diff --git a/java/java.lsp.server/nbcode/integration/src/org/netbeans/modules/nbcode/integration/commands/ProjectMetadataCommand.java b/java/java.lsp.server/nbcode/integration/src/org/netbeans/modules/nbcode/integration/commands/ProjectMetadataCommand.java
index 30e0142b2db1..206f0bed5ad8 100644
--- a/java/java.lsp.server/nbcode/integration/src/org/netbeans/modules/nbcode/integration/commands/ProjectMetadataCommand.java
+++ b/java/java.lsp.server/nbcode/integration/src/org/netbeans/modules/nbcode/integration/commands/ProjectMetadataCommand.java
@@ -24,22 +24,17 @@
 import com.google.gson.JsonObject;
 import com.google.gson.JsonPrimitive;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
-import org.eclipse.lsp4j.CodeAction;
-import org.eclipse.lsp4j.CodeActionParams;
 import org.netbeans.api.project.FileOwnerQuery;
 import org.netbeans.api.project.Project;
 import org.netbeans.api.project.ProjectActionContext;
 import org.netbeans.modules.java.lsp.server.LspServerState;
-import org.netbeans.modules.java.lsp.server.protocol.CodeActionsProvider;
-import org.netbeans.modules.java.lsp.server.protocol.NbCodeLanguageClient;
-import org.netbeans.modules.parsing.api.ResultIterator;
 import org.netbeans.modules.project.dependency.ProjectArtifactsQuery;
 import org.netbeans.modules.project.dependency.ProjectArtifactsQuery.ArtifactsResult;
+import org.netbeans.spi.lsp.CommandProvider;
 import org.openide.filesystems.FileObject;
 import org.openide.util.Lookup;
 import org.openide.util.RequestProcessor;
@@ -49,8 +44,8 @@
  *
  * @author sdedic
  */
-@ServiceProvider(service = CodeActionsProvider.class)
-public class ProjectMetadataCommand extends CodeActionsProvider {
+@ServiceProvider(service = CommandProvider.class)
+public class ProjectMetadataCommand implements CommandProvider {
     private static final String COMMAND_ARTIFACTS = "nbls.project.artifacts"; // NOI18N
     /**
      * @deprecated will be removed in NB 19
@@ -73,18 +68,13 @@ public ProjectMetadataCommand() {
         gson = new GsonBuilder().create();
     }
     
-    @Override
-    public List<CodeAction> getCodeActions(NbCodeLanguageClient client, ResultIterator resultIterator, CodeActionParams params) throws Exception {
-        return Collections.emptyList();
-    }
-
     @Override
     public Set<String> getCommands() {
         return COMMANDS;
     }
-    
+
     @Override
-    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {
+    public CompletableFuture<Object> runCommand(String command, List<Object> arguments) {
         if (arguments.size() < 1) {
             throw new IllegalArgumentException("Expected at least project URI/path");
         }
diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/db/DBAddConnection.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/db/DBAddConnection.java
index 557edb649c..e56b87b19c 100644
--- a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/db/DBAddConnection.java
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/db/DBAddConnection.java
@@ -21,6 +21,7 @@ package org.netbeans.modules.java.lsp.server.db;
 import com.google.gson.Gson;
 import com.google.gson.JsonNull;
 import com.google.gson.JsonObject;
+
 import java.net.URL;
 import java.sql.DatabaseMetaData;
 import java.sql.ResultSet;
@@ -28,33 +29,31 @@ import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.IdentityHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
-import java.util.stream.Collectors;
-import org.eclipse.lsp4j.CodeAction;
-import org.eclipse.lsp4j.CodeActionParams;
-import org.eclipse.lsp4j.MessageParams;
-import org.eclipse.lsp4j.MessageType;
-import org.eclipse.lsp4j.jsonrpc.messages.Either;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
 import org.netbeans.api.db.explorer.ConnectionManager;
 import org.netbeans.api.db.explorer.DatabaseConnection;
 import org.netbeans.api.db.explorer.DatabaseException;
 import org.netbeans.api.db.explorer.JDBCDriver;
 import org.netbeans.api.db.explorer.JDBCDriverManager;
-import org.netbeans.modules.java.lsp.server.input.InputBoxStep;
-import org.netbeans.modules.java.lsp.server.input.InputCallbackParams;
-import org.netbeans.modules.java.lsp.server.input.InputService;
-import org.netbeans.modules.java.lsp.server.protocol.CodeActionsProvider;
-import org.netbeans.modules.java.lsp.server.protocol.NbCodeLanguageClient;
-import org.netbeans.modules.java.lsp.server.input.QuickPickItem;
-import org.netbeans.modules.java.lsp.server.input.QuickPickStep;
-import org.netbeans.modules.java.lsp.server.input.ShowMutliStepInputParams;
-import org.netbeans.modules.parsing.api.ResultIterator;
+import org.netbeans.spi.lsp.CommandProvider;
+import org.openide.DialogDisplayer;
+import org.openide.NotifyDescriptor;
+import org.openide.NotifyDescriptor.ComposedInput;
+import org.openide.NotifyDescriptor.ComposedInput.Callback;
+import org.openide.NotifyDescriptor.InputLine;
+import org.openide.NotifyDescriptor.Message;
+import org.openide.NotifyDescriptor.PasswordLine;
+import org.openide.NotifyDescriptor.QuickPick;
+import org.openide.NotifyDescriptor.QuickPick.Item;
 import org.openide.filesystems.FileObject;
 import org.openide.filesystems.URLMapper;
-import org.openide.util.Lookup;
 import org.openide.util.NbBundle;
 import org.openide.util.lookup.ServiceProvider;
 
@@ -70,11 +69,11 @@ import org.openide.util.lookup.ServiceProvider;
     "MSG_SelectDriver=Select db driver",
     "MSG_DriverNotFound=Driver not found",
     "MSG_ConnectionAdded=Connection added",
-    "MSG_ConnectionFailed=Connection failed",
+    "MSG_ConnectionFailed=Could not connect to the database \"{0}\", user {1}:\n{2}",
     "MSG_SelectSchema=Select Database Schema"
 })
-@ServiceProvider(service = CodeActionsProvider.class)
-public class DBAddConnection extends CodeActionsProvider {
+@ServiceProvider(service = CommandProvider.class)
+public class DBAddConnection implements CommandProvider {
     public static final String DB_ADD_CONNECTION =  "nbls.db.add.connection"; // NOI18N
     public static final String USER_ID =  "userId"; // NOI18N
     public static final String PASSWORD =  "password"; // NOI18N
@@ -83,6 +82,7 @@ public class DBAddConnection extends CodeActionsProvider {
     public static final String SCHEMA =  "schema"; // NOI18N
     public static final String DISPLAY_NAME =  "displayName"; // NOI18N
 
+    private static final Logger LOG = Logger.getLogger(DBAddConnection.class.getName());
     private static final Map<String, String> urlTemplates = new HashMap<> ();
     static {
         urlTemplates.put("org.postgresql.Driver", "jdbc:postgresql://<HOST>:5432/<DB>");
@@ -95,12 +95,7 @@ public class DBAddConnection extends CodeActionsProvider {
     private final Gson gson = new Gson();
 
     @Override
-    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {
-        InputService.Registry inputServiceRegistry = Lookup.getDefault().lookup(InputService.Registry.class);
-        if (inputServiceRegistry == null) {
-            return null;
-        }
-        
+    public CompletableFuture<Object> runCommand(String command, List<Object> arguments) {
         if (arguments != null && !arguments.isEmpty()) {
             final Map m = arguments.get(0) instanceof JsonNull ? Collections.emptyMap() : gson.fromJson((JsonObject) arguments.get(0), Map.class);
             String userId = m != null ? (String) m.get(USER_ID) : null;
@@ -112,42 +107,44 @@ public class DBAddConnection extends CodeActionsProvider {
                 JDBCDriver[] driver = JDBCDriverManager.getDefault().getDrivers(driverClass);
                 if (driver != null && driver.length > 0) {
                     if (userId == null || password == null) {
-                        String inputId = inputServiceRegistry.registerInput(param -> {
-                            int totalSteps = 2;
-                            switch (param.getStep()) {
-                                case 1:
+                        Callback inputCallback = (input, number) -> {
+                            switch (number) {
+                                case 1: {
+                                    InputLine inputLine = new InputLine("", Bundle.MSG_EnterUsername());
                                     String userIdVal = userId != null ? userId : "";
-                                    return CompletableFuture.completedFuture(Either.forRight(new InputBoxStep(totalSteps, USER_ID, Bundle.MSG_EnterUsername(), userIdVal)));
-                                case 2:
-                                    Map<String, Either<List<QuickPickItem>, String>> data = param.getData();
-                                    Either<List<QuickPickItem>, String> userData = data.get(USER_ID);
-                                    if (userData != null) {
-                                        String passwordVal = password != null ? password : "";
-                                        return CompletableFuture.completedFuture(Either.forRight(new InputBoxStep(totalSteps, PASSWORD, null, Bundle.MSG_EnterPassword(), passwordVal, true)));
-                                    }
-                                    return CompletableFuture.completedFuture(null);
+                                    inputLine.setInputText(userIdVal);
+                                    return inputLine;
+                                }
+                                case 2: {
+                                    PasswordLine inputLine = new PasswordLine("", Bundle.MSG_EnterUsername());
+                                    String passwordVal = password != null ? password : "";
+                                    inputLine.setInputText(passwordVal);
+                                    return inputLine;
+                                }
                                 default:
-                                    return CompletableFuture.completedFuture(null);
+                                    return null;
                             }
-                        });
-                        client.showMultiStepInput(new ShowMutliStepInputParams(inputId, Bundle.MSG_AddDBConnection())).thenAccept(result -> {
-                            Either<List<QuickPickItem>, String> userData = result.get(USER_ID);
-                            Either<List<QuickPickItem>, String> passwordData = result.get(PASSWORD);
-                            DatabaseConnection dbconn = DatabaseConnection.create(driver[0], dbUrl, userData.getRight(), (String) m.get(SCHEMA), passwordData.getRight(), true, (String) m.get(DISPLAY_NAME));
+                        };
+                        DialogDisplayer.getDefault().notifyFuture(new ComposedInput(Bundle.MSG_AddDBConnection(), 2, inputCallback)).thenAccept(input -> {
+                            String newUser = ((InputLine) input.getInputs()[0]).getInputText();
+                            String newPasswd = ((InputLine) input.getInputs()[1]).getInputText();
+                            DatabaseConnection dbconn = DatabaseConnection.create(driver[0], dbUrl, newUser, (String) m.get(SCHEMA), newPasswd, true, (String) m.get(DISPLAY_NAME));
                             try {
                                 ConnectionManager.getDefault().addConnection(dbconn);
-                                client.showMessage(new MessageParams(MessageType.Info, Bundle.MSG_ConnectionAdded()));
+                                DialogDisplayer.getDefault().notifyLater(new Message(Bundle.MSG_ConnectionAdded(), Message.INFORMATION_MESSAGE));
                             } catch (DatabaseException ex) {
-                                client.showMessage(new MessageParams(MessageType.Error, ex.getMessage()));
+                                LOG.log(Level.INFO, "Add connection", ex);
+                                DialogDisplayer.getDefault().notifyLater(new Message(ex.getMessage(), Message.ERROR_MESSAGE));
                             }
                         });
                     } else {
                         DatabaseConnection dbconn = DatabaseConnection.create(driver[0], dbUrl, userId, (String) m.get(SCHEMA), password, true, (String) m.get(DISPLAY_NAME));
                         try {
                             ConnectionManager.getDefault().addConnection(dbconn);
-                            client.showMessage(new MessageParams(MessageType.Info, Bundle.MSG_ConnectionAdded()));
+                            DialogDisplayer.getDefault().notifyLater(new Message(Bundle.MSG_ConnectionAdded(), Message.INFORMATION_MESSAGE));
                         } catch (DatabaseException ex) {
-                            client.showMessage(new MessageParams(MessageType.Error, ex.getMessage()));
+                            LOG.log(Level.INFO, "Add connection with schema", ex);
+                            DialogDisplayer.getDefault().notifyLater(new Message(ex.getMessage(), Message.ERROR_MESSAGE));
                         }
                     }
                 }
@@ -156,127 +153,136 @@ public class DBAddConnection extends CodeActionsProvider {
         }
         
         JDBCDriver[] drivers = JDBCDriverManager.getDefault().getDrivers();
-        List<QuickPickItem> items = new ArrayList<>();
+        List<Item> items = new ArrayList<>();
+        Map<Item, JDBCDriver> item2Driver = new IdentityHashMap<>();
         for (int i = 0; i < drivers.length; i++) {
             URL[] jars = drivers[i].getURLs();
             if (jars != null && jars.length > 0) {
                 FileObject jarFO = URLMapper.findFileObject(jars[0]);
                 if (jarFO != null && jarFO.isValid()) {
-                    items.add(
-                            new QuickPickItem(drivers[i].getName(), null, drivers[i].getDisplayName() + " (" + drivers[i].getClassName() + ")", false, i) // NOI18N
-                    );
+                    Item item =
+                            new Item(drivers[i].getName(), drivers[i].getDisplayName() + " (" + drivers[i].getClassName() + ")"); // NOI18N
+                    items.add(item);
+                    item2Driver.put(item, drivers[i]);
                 }
             }
         }
         if (items.isEmpty()) {
-            client.showMessage(new MessageParams(MessageType.Error, Bundle.MSG_DriverNotFound()));
+            DialogDisplayer.getDefault().notifyLater(new Message(Bundle.MSG_DriverNotFound(), Message.ERROR_MESSAGE));
         } else {
             List<String> schemas = new ArrayList<>();
-            String inputId = inputServiceRegistry.registerInput(new InputService.Callback() {
+            Map<Item, String> item2Scheme = new IdentityHashMap<>();
+            Callback inputCallback = new Callback() {
                 @Override
-                public CompletableFuture<Either<QuickPickStep, InputBoxStep>> step(InputCallbackParams params) {
-                    Map<String, Either<List<QuickPickItem>, String>> data = params.getData();
-                    int totalSteps = 4;
-                    switch (params.getStep()) {
+                public NotifyDescriptor createInput(ComposedInput input, int number) {
+                    switch (number) {
                         case 1:
-                            return CompletableFuture.completedFuture(Either.forLeft(new QuickPickStep(totalSteps, DRIVER, Bundle.MSG_SelectDriver(), items)));
+                            return new QuickPick("", Bundle.MSG_SelectDriver(), items, false);
                         case 2: {
-                            Either<List<QuickPickItem>,String> driverData = data.get(DRIVER);
-                            if (driverData != null && !driverData.getLeft().isEmpty()) {
-                                int i = ((Double) driverData.getLeft().get(0).getUserData()).intValue();
-                                JDBCDriver driver = drivers[i];
-                                String urlTemplate = driver.getClassName() != null ? urlTemplates.get(driver.getClassName()) : "";
-                                if (urlTemplate == null) {
-                                    urlTemplate = "";
-                                }
-                                return CompletableFuture.completedFuture(Either.forRight(new InputBoxStep(totalSteps, DB_URL, Bundle.MSG_EnterDbUrl(), urlTemplate)));
+                            JDBCDriver driver = item2Driver.get(getSelectedItem((QuickPick) input.getInputs()[0]));
+                            String urlTemplate = driver.getClassName() != null ? urlTemplates.get(driver.getClassName()) : "";
+
+                            if (urlTemplate == null) {
+                                urlTemplate = "";
                             }
-                            return CompletableFuture.completedFuture(null);
+
+                            InputLine line = new InputLine("", Bundle.MSG_EnterDbUrl());
+
+                            line.setInputText(urlTemplate);
+
+                            return line;
                         }
                         case 3: {
-                            Either<List<QuickPickItem>,String> urlData = data.get(DB_URL);
-                            if (urlData != null && !urlData.getRight().isEmpty()) {
-                                return CompletableFuture.completedFuture(Either.forRight(new InputBoxStep(totalSteps, USER_ID, Bundle.MSG_EnterUsername(), "")));
-                            }
-                            return CompletableFuture.completedFuture(null);
+                            return new InputLine("", Bundle.MSG_EnterUsername());
                         }
                         case 4: {
-                            Either<List<QuickPickItem>,String> userData = data.get(USER_ID);
-                            if (userData != null && !userData.getRight().isEmpty()) {
-                                return CompletableFuture.completedFuture(Either.forRight(new InputBoxStep(totalSteps, PASSWORD, null, Bundle.MSG_EnterPassword(), "", true)));
-                            }
-                            return CompletableFuture.completedFuture(null);
+                            //should be:
+                            PasswordLine passwd = new PasswordLine("", Bundle.MSG_EnterPassword());
+                            passwd.setInputTextEventEnabled(true);
+                            passwd.addPropertyChangeListener(evt -> {
+                                if (evt.getPropertyName() == null ||
+                                    InputLine.PROP_INPUT_TEXT.equals(evt.getPropertyName())) {
+                                    validateConnection(passwd, input);
+                                }
+                            });
+                            return passwd;
                         }
                         case 5: {
-                            Either<List<QuickPickItem>,String> passwordData = data.get(PASSWORD);
-                            if (passwordData != null) {
-                                if (schemas.isEmpty()) {
-                                    client.showMessage(new MessageParams(MessageType.Info, Bundle.MSG_ConnectionAdded()));
-                                    return CompletableFuture.completedFuture(null);
-                                } else {
-                                    List<QuickPickItem> schemaItems = schemas.stream().map(schema -> new QuickPickItem(schema)).collect(Collectors.toList());
-                                    return CompletableFuture.completedFuture(Either.forLeft(new QuickPickStep(totalSteps + 1, SCHEMA, Bundle.MSG_SelectSchema(), schemaItems)));
+                            if (schemas.isEmpty()) {
+                                DialogDisplayer.getDefault().notifyLater(new Message(Bundle.MSG_ConnectionAdded(), Message.INFORMATION_MESSAGE));
+                                return null;
+                            } else {
+                                List<Item> schemaItems = new ArrayList<>();
+
+                                for (String schema : schemas) {
+                                    Item item = new Item(schema, schema);
+                                    schemaItems.add(item);
+                                    item2Scheme.put(item, schema);
                                 }
+
+                                return new QuickPick("", Bundle.MSG_SelectSchema(), schemaItems, false);
                             }
-                            return CompletableFuture.completedFuture(null);
                         }
                         default:
-                            return CompletableFuture.completedFuture(null);
+                            return null;
                     }
                 }
 
-                @Override
-                public CompletableFuture<String> validate(InputCallbackParams params) {
-                    Map<String, Either<List<QuickPickItem>, String>> data = params.getData();
-                    switch (params.getStep()) {
-                        case 4:
-                            Either<List<QuickPickItem>,String> passwordData = data.get(PASSWORD);
-                            if (passwordData != null) {
-                                Either<List<QuickPickItem>,String> driverData = data.get(DRIVER);
-                                Either<List<QuickPickItem>,String> urlData = data.get(DB_URL);
-                                Either<List<QuickPickItem>,String> userData = data.get(USER_ID);
-                                int i = ((Double) driverData.getLeft().get(0).getUserData()).intValue();
-                                JDBCDriver driver = drivers[i];
-                                boolean failed = true;
+                private void validateConnection(NotifyDescriptor current, ComposedInput input) {
+                    JDBCDriver driver = item2Driver.get(getSelectedItem((QuickPick) input.getInputs()[0]));
+                    String url = ((InputLine) input.getInputs()[1]).getInputText();
+                    String user = ((InputLine) input.getInputs()[2]).getInputText();
+                    String passwd = ((InputLine) input.getInputs()[3]).getInputText();
+                    boolean failed = true;
 
-                                schemas.clear();
-                                DatabaseConnection dbconn = DatabaseConnection.create(driver, urlData.getRight(), userData.getRight(), null, passwordData.getRight(), true);
-                                try {
-                                    ConnectionManager.getDefault().addConnection(dbconn);
-                                    schemas.addAll(getSchemas(dbconn));
-                                    failed = false;
-                                } catch(DatabaseException | SQLException ex) {
-                                    return CompletableFuture.completedFuture(ex.getMessage());
-                                } finally {
-                                    try {
-                                        if (failed || !schemas.isEmpty()) {
-                                            ConnectionManager.getDefault().removeConnection(dbconn);
-                                        }
-                                    } catch (DatabaseException ex) {}
-                                }
+                    schemas.clear();
+
+                    DatabaseConnection dbconn = DatabaseConnection.create(driver, url, user, null, passwd, true);
+                    try {
+                        ConnectionManager.getDefault().addConnection(dbconn);
+                        schemas.addAll(getSchemas(dbconn));
+                        failed = false;
+                    } catch(SQLException ex) {
+                        LOG.log(Level.INFO, "validate", ex);
+                        current.createNotificationLineSupport().setErrorMessage(ex.getMessage());
+                        current.setValid(false);
+                    } catch (DatabaseException ex) {
+                        String message;
+                        Throwable cause = ex.getCause();
+                        if (cause == null) cause = ex;
+                        if (cause.getCause() != null) {
+                            message = Bundle.MSG_ConnectionFailed(url, user, cause.getCause().getMessage());
+                        } else {
+                            message = cause.getMessage();
+                        }
+                        LOG.log(Level.INFO, "validate", ex);
+                        current.createNotificationLineSupport().setErrorMessage(message);
+                        current.setValid(false);
+                    } finally {
+                        try {
+                            if (failed || !schemas.isEmpty()) {
+                                ConnectionManager.getDefault().removeConnection(dbconn);
                             }
-                            break;
+                        } catch (DatabaseException ex) {}
                     }
-                    return CompletableFuture.completedFuture(null);
                 }
-            });
-            return client.showMultiStepInput(new ShowMutliStepInputParams(inputId, Bundle.MSG_AddDBConnection())).thenApply(result -> {
-                Either<List<QuickPickItem>,String> driverData = result.get(DRIVER);
-                Either<List<QuickPickItem>,String> urlData = result.get(DB_URL);
-                Either<List<QuickPickItem>,String> userData = result.get(USER_ID);
-                Either<List<QuickPickItem>,String> passwordData = result.get(PASSWORD);
-                Either<List<QuickPickItem>,String> schemaData = result.get(SCHEMA);
-                if (driverData != null && urlData != null && userData != null && passwordData != null && schemaData != null && !schemaData.getLeft().isEmpty()) {
-                    int i = ((Double) driverData.getLeft().get(0).getUserData()).intValue();
-                    JDBCDriver driver = drivers[i];
-                    String schema = schemaData.getLeft().get(0).getLabel();
-                    DatabaseConnection dbconn = DatabaseConnection.create(driver, urlData.getRight(), userData.getRight(), schema, passwordData.getRight(), true);
+            };
+            return DialogDisplayer.getDefault().notifyFuture(new ComposedInput(Bundle.MSG_AddDBConnection(), 4, inputCallback)).thenApply(input -> {
+                JDBCDriver driver = item2Driver.get(getSelectedItem((QuickPick) input.getInputs()[0]));
+                String url = ((InputLine) input.getInputs()[1]).getInputText();
+                String user = ((InputLine) input.getInputs()[2]).getInputText();
+                String passwd = ((InputLine) input.getInputs()[3]).getInputText();
+                String schema = item2Scheme.get(getSelectedItem((QuickPick) input.getInputs()[4]));
+
+                if (driver != null && url != null && user != null && passwd != null && schema != null) {
+                    DatabaseConnection dbconn = DatabaseConnection.create(driver, url, user, schema, passwd, true);
                     try {
                         ConnectionManager.getDefault().addConnection(dbconn);
+                        DialogDisplayer.getDefault().notifyLater(new Message(Bundle.MSG_ConnectionAdded(), Message.INFORMATION_MESSAGE));
                     } catch (DatabaseException ex) {
-                        client.showMessage(new MessageParams(MessageType.Error, ex.getMessage()));
+                        LOG.log(Level.INFO, "add", ex);
+                        DialogDisplayer.getDefault().notifyLater(new Message(ex.getMessage(), Message.ERROR_MESSAGE));
                     }
-                    client.showMessage(new MessageParams(MessageType.Info, Bundle.MSG_ConnectionAdded()));
                 }
                 return null;
             });
@@ -284,6 +290,15 @@ public class DBAddConnection extends CodeActionsProvider {
         return null;
     }
 
+    private static Item getSelectedItem(QuickPick pick) {
+        for (Item i : pick.getItems()) {
+            if (i.isSelected()) {
+                return i;
+            }
+        }
+        return null;
+    }
+
     private static List<String> getSchemas(DatabaseConnection dbconn) throws SQLException, DatabaseException {
         List<String> schemas = new ArrayList<>();
         if (ConnectionManager.getDefault().connect(dbconn)) {
@@ -305,9 +320,4 @@ public class DBAddConnection extends CodeActionsProvider {
         return Collections.singleton(DB_ADD_CONNECTION);
     }
 
-    @Override
-    public List<CodeAction> getCodeActions(NbCodeLanguageClient client, ResultIterator resultIterator, CodeActionParams params) throws Exception {
-        return Collections.emptyList();
-    }
-    
 }
diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/db/DBCommandProvider.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/db/DBCommandProvider.java
index 1925d3837655..0dccd718e874 100644
--- a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/db/DBCommandProvider.java
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/db/DBCommandProvider.java
@@ -18,19 +18,18 @@
  */
 package org.netbeans.modules.java.lsp.server.db;
 
+import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
-import org.eclipse.lsp4j.CodeAction;
-import org.eclipse.lsp4j.CodeActionParams;
+
 import org.netbeans.api.db.explorer.ConnectionManager;
 import org.netbeans.api.db.explorer.DatabaseConnection;
 import org.netbeans.modules.java.lsp.server.explorer.TreeNodeRegistry;
-import org.netbeans.modules.java.lsp.server.protocol.CodeActionsProvider;
-import org.netbeans.modules.java.lsp.server.protocol.NbCodeLanguageClient;
-import org.netbeans.modules.parsing.api.ResultIterator;
+import org.netbeans.spi.lsp.CommandProvider;
 import org.openide.nodes.Node;
 import org.openide.util.Lookup;
 import org.openide.util.lookup.ServiceProvider;
@@ -39,17 +38,16 @@
  *
  * @author sdedic
  */
-@ServiceProvider(service = CodeActionsProvider.class)
-public class DBCommandProvider extends CodeActionsProvider {
+@ServiceProvider(service = CommandProvider.class)
+public class DBCommandProvider implements CommandProvider{
     private static final String  COMMAND_GET_PREFERRED_CONNECTION = "nbls.db.preferred.connection";
     
-    @Override
-    public List<CodeAction> getCodeActions(NbCodeLanguageClient client, ResultIterator resultIterator, CodeActionParams params) throws Exception {
-        return Collections.emptyList();
-    }
+    private static final Set<String> COMMANDS = new HashSet<>(Arrays.asList(
+        COMMAND_GET_PREFERRED_CONNECTION
+    ));
 
     @Override
-    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {
+    public CompletableFuture<Object> runCommand(String command, List<Object> arguments) {
         TreeNodeRegistry r = Lookup.getDefault().lookup(TreeNodeRegistry.class);
         DatabaseConnection conn = ConnectionManager.getDefault().getPreferredConnection(true);
         if (conn == null || r == null) {
diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/CodeActionsProvider2CommandProviderBridge.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/CodeActionsProvider2CommandProviderBridge.java
new file mode 100644
index 000000000000..fc2410338f3e
--- /dev/null
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/CodeActionsProvider2CommandProviderBridge.java
@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.netbeans.modules.java.lsp.server.protocol;
+
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import org.eclipse.lsp4j.CodeAction;
+import org.eclipse.lsp4j.CodeActionParams;
+import org.netbeans.modules.parsing.api.ResultIterator;
+import org.netbeans.spi.lsp.CommandProvider;
+import org.openide.util.Lookup;
+import org.openide.util.lookup.ServiceProvider;
+
+@ServiceProvider(service=CodeActionsProvider.class)
+public class CodeActionsProvider2CommandProviderBridge extends CodeActionsProvider {
+
+    @Override
+    public Set<String> getCommands() {
+        Set<String> allCommands = new HashSet<>();
+
+        for (CommandProvider cmdProvider : Lookup.getDefault().lookupAll(CommandProvider.class)) {
+            allCommands.addAll(cmdProvider.getCommands());
+        }
+
+        return allCommands;
+    }
+
+    @Override
+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {
+        for (CommandProvider cmdProvider : Lookup.getDefault().lookupAll(CommandProvider.class)) {
+            if (cmdProvider.getCommands().contains(command)) {
+                return cmdProvider.runCommand(command, arguments);
+            }
+        }
+
+        return CompletableFuture.completedFuture(null);
+    }
+
+    @Override
+    public List<CodeAction> getCodeActions(NbCodeLanguageClient client, ResultIterator resultIterator, CodeActionParams params) throws Exception {
+        return Collections.emptyList();
+    }
+
+}
diff --git a/platform/openide.dialogs/apichanges.xml b/platform/openide.dialogs/apichanges.xml
index 55b05eeff1e9..42405fdf9108 100644
--- a/platform/openide.dialogs/apichanges.xml
+++ b/platform/openide.dialogs/apichanges.xml
@@ -26,6 +26,21 @@
 <apidef name="dialogs">Dialogs API</apidef>
 </apidefs>
 <changes>
+    <change>
+         <api name="dialogs"/>
+         <summary>InputLine.PROP_INPUT_TEXT</summary>
+         <version major="7" minor="68"/>
+         <date day="30" month="6" year="2023"/>
+         <author login="jlahoda"/>
+         <compatibility addition="yes" binary="compatible" source="compatible" semantic="compatible" deprecation="no" deletion="no" modification="no"/>
+         <description>
+             <p>
+                 Added <code>PROP_INPUT_TEXT</code> event to the <code>InputLine</code>,
+                 that may optionally be fired when the input text changes
+             </p>
+         </description>
+         <class package="org.openide" name="NotifyDescriptor"/>
+    </change>
     <change>
          <api name="dialogs"/>
          <summary>NotifyDescriptor.ComposedInput added</summary>
diff --git a/platform/openide.dialogs/manifest.mf b/platform/openide.dialogs/manifest.mf
index 36e9c5b76e..8f533f128a 100644
--- a/platform/openide.dialogs/manifest.mf
+++ b/platform/openide.dialogs/manifest.mf
@@ -1,6 +1,6 @@
 Manifest-Version: 1.0
 OpenIDE-Module: org.openide.dialogs
-OpenIDE-Module-Specification-Version: 7.68
+OpenIDE-Module-Specification-Version: 7.70
 OpenIDE-Module-Localizing-Bundle: org/openide/Bundle.properties
 AutoUpdate-Essential-Module: true

diff --git a/platform/openide.dialogs/src/org/openide/NotifyDescriptor.java b/platform/openide.dialogs/src/org/openide/NotifyDescriptor.java
index 3cb28029ec83..7628df3d8ad9 100644
--- a/platform/openide.dialogs/src/org/openide/NotifyDescriptor.java
+++ b/platform/openide.dialogs/src/org/openide/NotifyDescriptor.java
@@ -33,6 +33,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
 import javax.swing.BorderFactory;
 import javax.swing.ButtonGroup;
 import javax.swing.GroupLayout;
@@ -49,6 +50,8 @@
 import javax.swing.JToggleButton;
 import javax.swing.LayoutStyle;
 import javax.swing.UIManager;
+import javax.swing.event.DocumentEvent;
+import javax.swing.event.DocumentListener;
 import org.openide.awt.Mnemonics;
 import org.openide.util.NbBundle;
 
@@ -1032,10 +1035,21 @@ JTextField createTextField() {
     * @author Dafe Simonek
     */
     public static class InputLine extends NotifyDescriptor {
+        /**
+         * Property whose value is the input text, an event is fired
+         * when the input text's value changes,
+         * if enabled using {@link #setInputTextEventsEnabled(boolean) }.
+         *
+         * @since 7.70
+         */
+        public static final String PROP_INPUT_TEXT = "inputText"; // NOI18N
+
         /**
         * The text field used to enter the input.
         */
         protected JTextField textField;
+        private final AtomicBoolean inputTextEventSuppressed = new AtomicBoolean();
+        private final AtomicBoolean inputTextEventEnabled = new AtomicBoolean();
 
         /** Construct dialog with the specified title and label text.
         * @param text label text
@@ -1070,8 +1084,28 @@ public String getInputText() {
         * @param text the new text
         */
         public void setInputText(final String text) {
-            textField.setText(text);
-            textField.selectAll();
+            inputTextEventSuppressed.set(true);
+            try {
+                textField.setText(text);
+                textField.selectAll();
+                if (inputTextEventEnabled.get()) {
+                    firePropertyChange(PROP_INPUT_TEXT, null, null);
+                }
+            } finally {
+                inputTextEventSuppressed.set(false);
+            }
+        }
+
+        /**
+         * Enable the {@link #PROP_INPUT_TEXT} when the input text is changed.
+         *
+         * @param value {@code true} if the {@code PROP_INPUT_TEXT} even should be fired
+         *              when the input text is modified, {@code false} otherwise.
+         *
+         * @since 7.70
+         */
+        public void setInputTextEventEnabled(boolean value) {
+            inputTextEventEnabled.set(value);
         }
 
         /** Make a component representing the input line.
@@ -1087,6 +1121,24 @@ protected Component createDesign(final String text) {
 
             boolean longText = text.length () > 80;
             textField = createTextField(); 
+            textField.getDocument().addDocumentListener(new DocumentListener() {
+                @Override
+                public void insertUpdate(DocumentEvent e) {
+                    if (inputTextEventEnabled.get() && !inputTextEventSuppressed.get()) {
+                        firePropertyChange(PROP_INPUT_TEXT, null, null);
+                    }
+                }
+
+                @Override
+                public void removeUpdate(DocumentEvent e) {
+                    if (inputTextEventEnabled.get() && !inputTextEventSuppressed.get()) {
+                        firePropertyChange(PROP_INPUT_TEXT, null, null);
+                    }
+                }
+
+                @Override
+                public void changedUpdate(DocumentEvent e) {}
+            });
             textLabel.setLabelFor(textField);
             
             textField.requestFocus();
@@ -1162,7 +1214,7 @@ public void actionPerformed (java.awt.event.ActionEvent evt) {
             
             return panel;
         }
-        
+
         JTextField createTextField() {
             return new JTextField(25);
         }
diff --git a/platform/openide.dialogs/test/unit/src/org/openide/NotifyDescriptorTest.java b/platform/openide.dialogs/test/unit/src/org/openide/NotifyDescriptorTest.java
index bf05a9180cfe..cdbfe948128d 100644
--- a/platform/openide.dialogs/test/unit/src/org/openide/NotifyDescriptorTest.java
+++ b/platform/openide.dialogs/test/unit/src/org/openide/NotifyDescriptorTest.java
@@ -19,10 +19,15 @@
 package org.openide;
 
 import java.awt.GraphicsEnvironment;
+import java.beans.PropertyChangeEvent;
+import java.util.ArrayList;
+import java.util.List;
 import javax.swing.*;
+import javax.swing.text.BadLocationException;
 import junit.framework.Test;
 import junit.framework.TestSuite;
 import org.netbeans.junit.*;
+import org.openide.NotifyDescriptor.InputLine;
 
 /** Testing issue 56878.
  * @author  Jiri Rechtacek
@@ -91,5 +96,42 @@ public void testNoDefaultClose() {
 
         dd.setNoDefaultClose( false );
         assertEquals( JDialog.DISPOSE_ON_CLOSE, dlg.getDefaultCloseOperation() );
-}
+    }
+
+    public void testInputLineInputEvents() throws BadLocationException {
+        JTextField input = new JTextField();
+        InputLine il = new InputLine("test", "test") {
+            @Override
+            JTextField createTextField() {
+                return input;
+            }
+        };
+        List<PropertyChangeEvent> events = new ArrayList<>();
+
+        il.addPropertyChangeListener(evt -> events.add(evt));
+
+        il.setInputText("new text 1");
+        input.getDocument().insertString(0, "a", null);
+        input.getDocument().remove(0, 1);
+
+        assertEquals(events.toString(), 0, events.size());
+
+        il.setInputTextEventEnabled(true);
+        il.setInputText("new text 2");
+
+        assertEquals(events.toString(), 1, events.size());
+
+        events.clear();
+
+        input.getDocument().insertString(0, "a", null);
+
+        assertEquals(events.toString(), 1, events.size());
+
+        events.clear();
+        input.getDocument().remove(0, 1);
+
+        assertEquals(events.toString(), 1, events.size());
+
+        events.clear();
+    }
 }
